# -*- coding: utf-8 -*-
"""step1_fwi_intensity.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/138A7xbI3siL10ggolgYU9aaCVSoDgUHZ
"""

import xarray as xr
import numpy as np
import pandas as pd
import geopandas as gpd
import matplotlib.pyplot as plt
import contextily as ctx
import os
import rasterio

# Define the geographic boundaries for the UK
# The mainland areas lie between latitudes 49 N and 59 N (the Shetland Islands reach to nearly 61 N), and longitudes 8 W to 2 E.
min_lon, min_lat, max_lon, max_lat = -9, 34, 32, 72
GEO_BOUND_UK = (min_lon, min_lat, max_lon, max_lat)

min_lon, min_lat, max_lon, max_lat = -31, 34, 40, 72
GEO_BOUND_EU = (min_lon, min_lat, max_lon, max_lat)

min_lon, min_lat, max_lon, max_lat = -141, 42, -52, 83

"""# 1. Copernicus Daily FWI in UK

# 1.1 FWI Data Loading

Source:https://cds.climate.copernicu.eu/cdsapp#!/dataset/cems-fire-historical-v1?tab=overview
"""

# os.path.exists('../../climada_petals/data/wildfire/2001_fwi_fire_intensity_expriment')
os.path.exists('../../climada_petals/data/wildfire/copernicus_fwi/interpolated25_netcdf/2013/')

# folder = '../../climada_petals/data/wildfire/2001_fwi_fire_intensity_expriment'
folder = '../../climada_petals/data/wildfire/copernicus_fwi/interpolated25_netcdf/2013/'
# fwi2001_filepath = 'fwi2001.grib'
# fwi_ds = xr.open_dataset(os.path.join(folder, fwi2001_filepath), engine='cfgrib')
fwi2001_filepath = 'fwi2013.nc'
fwi_ds = xr.open_dataset(os.path.join(folder, fwi2001_filepath))
fwi_ds

"""# 1.2 Data analysis and change to geodataframe"""

min_latitude = fwi_ds['latitude'].min().values
max_latitude = fwi_ds['latitude'].max().values

min_longitude = fwi_ds['longitude'].min().values
max_longitude = fwi_ds['longitude'].max().values

print(f"Latitude ranges from {min_latitude} to {max_latitude}")
print(f"Longitude ranges from {min_longitude} to {max_longitude}")

fwi_ds['fwinx'].values.shape

np.isnan(fwi_ds['fwinx'].values[0]).all()

fwi_ds.dims

fwi_df = fwi_ds.to_dataframe()
fwi_df.shape

fwi_df.reset_index(inplace=True)

fwi_df

fwi_df.columns

fwi_df['latitude'].describe()

print(min_lon, max_lon)

fwi_df['longitude'] = fwi_df['longitude'] - 180

fwi_uk_df = fwi_df[(fwi_df['longitude'] >= min_lon) & (fwi_df['longitude'] <= max_lon) & (fwi_df['latitude'] >= min_lat) & (fwi_df['latitude'] <= max_lat)]
fwi_uk_df.shape

# Convert df to GeoDataFrame
# fwi_uk_gdf = gpd.GeoDataFrame(
#     fwi_uk_df,
#     geometry=gpd.points_from_xy(fwi_uk_df['longitude'], fwi_uk_df['latitude']),
#     crs='EPSG:4326')

fwi_uk_gdf = gpd.GeoDataFrame(
    fwi_df,
    geometry=gpd.points_from_xy(fwi_df['longitude'], fwi_df['latitude']),
    crs='EPSG:4326')

fwi_uk_gdf['time'] = pd.to_datetime(fwi_uk_gdf['time'])
fwi_uk_gdf

fwi_uk_gdf.reset_index()['time'].unique()

save_path = '../../climada_petals/data/wildfire/intermediate/'
fwi_uk_gdf.to_file(os.path.join(save_path, 'fwi_uk_gdf'), driver='GPKG')

"""# 1.3 Display FWI Data on map of UK on 2001-01"""

# select FWI Data on map of UK on 2001-01


fwi_uk_2001_01_df = fwi_uk_gdf[fwi_uk_gdf['time'].dt.to_period('D') == '2013-01-05']
fwi_uk_2001_01_df.shape

# Convert df to GeoDataFrame
fwi_uk_2001_01_gdf = gpd.GeoDataFrame(
    fwi_uk_2001_01_df,
    geometry=gpd.points_from_xy(fwi_uk_2001_01_df['longitude'], fwi_uk_2001_01_df['latitude']),
    crs='EPSG:4326')

fig, ax = plt.subplots(figsize=(20, 8))
fwi_uk_gdf.plot(ax=ax, column='fwinx', legend=True, cmap='hot', markersize=1)

# Set the extent of the axes to match the spatial extent of your data
# ax.set_xlim(min_lon, max_lon)
# ax.set_ylim(min_lat, max_lat)

ctx.add_basemap(ax, crs='EPSG:4326', source=ctx.providers.OpenStreetMap.Mapnik)



"""# 2. Nasa-FIRMS Daily Fire Intensity Data in UK (many dates are not available)

Source: https://firms.modaps.eosdis.nasa.gov/download/
CRS: EPSG:4326, also known as WGS 84 (https://www.earthdata.nasa.gov/faq/firms-faq#ed-nrt-standard)
Data Description:
-- fire_archive_M-C61_xx = MODIS standard quality Thermal Anomalies / Fire locations
                        processed by the University of Maryland with a 3-month
                        lag and distributed by FIRMS. These standard data (MCD14ML)
                        replace the NRT (MCD14DL) files when available.

Data not used:
-- fire_nrt_M-C61_xx = MODIS Near Real Time Thermal Anomalies/Fire locations

# 2.1 Fire Intensity Data Loading
"""

# os.path.exists('../../climada_petals/data/wildfire/2001_fwi_fire_intensity_expriment/fire_intensity_csv/')
os.path.exists('../../climada_petals/data/wildfire/nasa_fire_intensity/2013/')

# folder = '../../climada_petals/data/wildfire/2001_fwi_fire_intensity_expriment/fire_intensity_csv/'
folder = '../../climada_petals/data/wildfire/nasa_fire_intensity/2013/'
fire_intensity_filepath = '2013.csv'
fire_intensity_df = pd.read_csv(os.path.join(folder, fire_intensity_filepath))

# fire_intensity_df = pd.read_csv('C:/Users\zhong\Documents\Python Projects\climada_petals\doc\my_scripts\Wildfire_US2018.csv')

"""# 2.2 Data analysis and change to geodataframe"""

# Convert df to GeoDataFrame
fire_intensity_gdf = gpd.GeoDataFrame(
    fire_intensity_df,
    geometry=gpd.points_from_xy(fire_intensity_df['longitude'], fire_intensity_df['latitude']),
    crs='EPSG:4326')

fire_intensity_gdf



min_latitude = fire_intensity_gdf['latitude'].min()
max_latitude = fire_intensity_gdf['latitude'].max()

min_longitude = fire_intensity_gdf['longitude'].min()
max_longitude = fire_intensity_gdf['longitude'].max()

print(f"Latitude ranges from {min_latitude} to {max_latitude}")
print(f"Longitude ranges from {min_longitude} to {max_longitude}")

fire_intensity_uk_gdf = fire_intensity_gdf[(fire_intensity_gdf['longitude'] >= min_lon) & (fire_intensity_gdf['longitude'] <= max_lon) & (fire_intensity_gdf['latitude'] >= min_lat) & (fire_intensity_gdf['latitude'] <= max_lat)]
# Method 2
# fire_intensity_uk_gdf = fire_intensity_gdf.cx[min_lon:max_lon, min_lat:max_lat]
fire_intensity_uk_gdf.shape

# Calculate the number of rows for same 'longitude' and 'latitude' under consecutive days
import pandas as pd
#
# # Example DataFrame
# df = pd.DataFrame({
#     'brightness': [300, 350, 400, 450, 500, 350, 300, 450],
#     'acq_data': ['2023-01-01', '2023-01-02', '2023-01-01', '2023-01-03', '2023-01-04', '2023-01-05', '2023-01-06', '2023-01-02'],
#     'latitude': [10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 20.0],
#     'longitude': [20.0, 20.0, 30.0, 30.0, 30.0, 30.0, 30.0, 20.0]
# })

# Ensure 'acq_data' is in datetime format
fire_intensity_gdf['acq_date'] = pd.to_datetime(fire_intensity_gdf['acq_date'])

# Sort by 'longitude', 'latitude', and 'acq_data'
df = fire_intensity_gdf.sort_values(by=['longitude', 'latitude', 'acq_date'])

# Define a function to find consecutive days and mark those rows
def mark_consecutive_days(group):
    group = group.sort_values(by='acq_date')
    group['day_diff'] = group['acq_date'].diff().dt.days
    group['is_consecutive'] = (group['day_diff'] == 1) | (group['day_diff'].shift(-1) == 1)
    return group

# Apply the function and mark the rows
marked_df = df.groupby(['longitude', 'latitude']).apply(mark_consecutive_days).reset_index(drop=True)

# Filter rows that have consecutive days
consecutive_rows = marked_df[marked_df['is_consecutive']]

# Drop the auxiliary columns
consecutive_rows = consecutive_rows.drop(columns=['day_diff', 'is_consecutive'])

# Display the result
consecutive_rows

fire_intensity_uk_gdf.to_file(os.path.join(save_path, 'fire_intensity_uk_gdf'), driver='GPKG')

fire_intensity_uk_2001_01_01_gdf = fire_intensity_uk_gdf[fire_intensity_uk_gdf['acq_date'] == '2001-01-01']
fire_intensity_uk_2001_01_01_gdf.shape

fire_intensity_uk_gdf

fire_intensity_uk_gdf['acq_date'].unique()

"""# 2.3 Display fire intensity data on map of UK on 2001-01-01"""

# Plot the fire intensity data on a map of the UK
fig, ax = plt.subplots(figsize=(20, 10))
fire_intensity_uk_gdf.plot(ax=ax, column='brightness', legend=True, cmap='hot', markersize=5)
ctx.add_basemap(ax, crs="EPSG:4326", source=ctx.providers.OpenStreetMap.Mapnik)



"""# 3. Finding relationship| of FWI and Fire Intensity Data

# 3.1 Match daily FWI and Fire Intensity Data
"""

fwi_uk_gdf.reset_index(inplace=True)

# Convert 'time' to datetime format and extract date
fwi_uk_gdf['time'] = pd.to_datetime(fwi_uk_gdf['time']).dt.date

# Ensure 'acq_date' is in date format
fire_intensity_uk_gdf['acq_date'] = pd.to_datetime(fire_intensity_uk_gdf['acq_date']).dt.date

# Rename columns for clarity
fire_intensity_uk_gdf.rename(columns={'acq_date': 'date'}, inplace=True)
fwi_uk_gdf.rename(columns={'time': 'date'}, inplace=True)

# Perform the spatial join on the same date
fire_intensity_uk_gdf = fire_intensity_uk_gdf.set_index('date')
fwi_uk_gdf = fwi_uk_gdf.set_index('date')

# Use KDTree
'''
1. For each date in fire_intensity_uk_gdf, subsets of fire_intensity_uk_gdf and fwi_uk_gdf are created.
2. cKDTree is built using the coordinates of fwi_subset.
3. The nearest neighbor for each point in fire_subset is found using the tree.
4. The result is a DataFrame where each row from fire_intensity_uk_gdf is matched with its nearest neighbor from fwi_uk_gdf for the same date, including the calculated distance.
5. If one row in fire_intensity_uk_gdf has same distance for multiple rows in fwi_uk_gdf: Generally, cKDTree will return the first occurrence of the nearest neighbor found in its internal tree structure. Assuming a left-to-right and top-to-bottom traversal, the row with Index 0 will be chosen if the distances are equal.
'''
from shapely.geometry import Point
from scipy.spatial import cKDTree
import numpy as np

# Function to ensure GeoDataFrame has correct geometry and CRS
def ensure_geodataframe(df, crs="EPSG:4326"):
    if isinstance(df, pd.Series):
        df = pd.DataFrame([df])
    if not isinstance(df, gpd.GeoDataFrame):
        df = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df.longitude, df.latitude))
    if df.crs is None:
        df.set_crs(crs, inplace=True)
    return df

# Ensure both dataframes have the correct geometry and CRS
fire_intensity_uk_gdf = ensure_geodataframe(fire_intensity_uk_gdf)
fwi_uk_gdf = ensure_geodataframe(fwi_uk_gdf)

# Function to find nearest neighbors
def find_nearest(df1, df2, date):
    tree = cKDTree(np.c_[df2.geometry.x, df2.geometry.y])
    distances, indices = tree.query(np.c_[df1.geometry.x, df1.geometry.y], k=1)
    nearest_df2 = df2.iloc[indices].reset_index(drop=True)
    nearest_df2.columns = [f"{col}_nearest" for col in nearest_df2.columns]
    result = pd.concat([df1.reset_index(drop=True), nearest_df2, pd.Series(distances, name='distance')], axis=1)
    result['date'] = date
    return result

# Re-split and find nearest neighbors for each date
merged_dfs = []

for date in fire_intensity_uk_gdf.index.unique():
    if date in fwi_uk_gdf.index.unique():
        fire_subset = ensure_geodataframe(fire_intensity_uk_gdf.loc[[date]])
        fwi_subset = ensure_geodataframe(fwi_uk_gdf.loc[[date]])

        merged_dfs.append(find_nearest(fire_subset, fwi_subset, date))

# Concatenate all the merged DataFrames
merged_gdf = pd.concat(merged_dfs, ignore_index=True)

merged_gdf



# Using sjoin_nearest


# Reproject to a common projected CRS for accurate distance calculations
fire_intensity_uk_gdf = fire_intensity_uk_gdf.to_crs("EPSG:4326")
fwi_uk_gdf = fwi_uk_gdf.to_crs("EPSG:4326") # EPSG:27700 will eliminate the warning

# Merge using sjoin_nearest for each date
sjoin_merged_dfs = []

for date in fire_intensity_uk_gdf.index.unique():
    if date in fwi_uk_gdf.index.unique():
        fire_subset = fire_intensity_uk_gdf.loc[[date]]
        fwi_subset = fwi_uk_gdf.loc[[date]]

        merged_df = gpd.sjoin_nearest(fire_subset, fwi_subset, how='left')
        merged_df['date'] = date
        sjoin_merged_dfs.append(merged_df)

# Concatenate all the merged GeoDataFrames
sjoin_merged_gdf = pd.concat(sjoin_merged_dfs, ignore_index=True)

sjoin_merged_gdf

script_sjoin_merged_gdf = gpd.read_file(os.path.join(save_path, 'merged_gdf'))

script_sjoin_merged_gdf

merged_gdf['fwinx_nearest'].equals(sjoin_merged_gdf['fwinx'])

merged_gdf['brightness'].equals(sjoin_merged_gdf['brightness'])

script_sjoin_merged_gdf['fwi'].equals(sjoin_merged_gdf['fwinx'])

print(script_sjoin_merged_gdf['fwi'][468])
print(sjoin_merged_gdf['fwinx'][468])
print(script_sjoin_merged_gdf['fwi'][468] == sjoin_merged_gdf['fwinx'][468])

# Find rows where the rounded columns are not equal
not_equal_bools = script_sjoin_merged_gdf['fwi'].fillna(0) != sjoin_merged_gdf['fwinx'].fillna(0)
print(len(script_sjoin_merged_gdf['fwi'][not_equal_bools]), len(sjoin_merged_gdf['fwinx'][not_equal_bools]))
not_equal_df = pd.DataFrame(script_sjoin_merged_gdf['fwi'][not_equal_bools], sjoin_merged_gdf['fwinx'][not_equal_bools])
not_equal_df

script_sjoin_merged_gdf['brightness'].equals(sjoin_merged_gdf['brightness'])

